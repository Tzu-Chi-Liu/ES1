# ES1A 1-dimensional electrostatic particle-in-cell plasma simulation code## Requirements- Python - Numpy- Matplotlib## Running the code- Terminal:     1. Uncomment `input_file_loc=sys.argv[1] # For running in terminal` in ES1.py (should be at line 10)    2. Comment `input_file_loc='simulation_results/example_input_file/input.txt' # for running in IDE (ex:Spyder)` in ES1.py (should be at line 11)    3. Run `python ES1.py <path_to_input.txt>` in terminal- IDE(ex: Spyder):     1. Uncomment `input_file_loc='simulation_results/example_input_file/input.txt' # for running in IDE (ex:Spyder)` in ES1.py (should be at line 11)    2. Comment `input_file_loc=sys.argv[1] # For running in terminal` in ES1.py (should be at line 10)    3. Run normally as any other scripts## Simulation problems- Cold plasma oscillations- Warm plasma waves- Two stream instability- Beam plasma instability- Landau damping## To do list - Negative k?- Use separate `example_input_file/input.txt` for different Simulation problems- Add phi(k,t)- Add 2d imshow for field_history- Document which axis corresponds to what for field_history, field_kt, field_omegak- Set amplitude for excited modes in `input.txt`- Will naming all figures axes to `fig,ax` in functions make bad things happen?- Add and plot theoretical dispersion relations for Simulation problems listed below- Set axis range for plots - Add colorbar for imshow() plots- Separate plot_* from save_*- One function for plotting one figure?- Use steps instead of dt?- For `input.txt` and `build.py`:    - Write prepared-for-running parameters for Simulation problems listed below- Use consistent variable names (capitalize, underscore, etc)- Need to explicitly add fixed ion background?- Input file use .py instead of .txt?- Rename parameters with self-explanatory names (ex:t->step)- on/off for plt.show()- Read from input file - Save output to file- Add plotters- 1d2v ES1 with (const) B field- Add serial/parallel c++ version## Stuff- Save `input.txt` before running?- dt affects energy conservation- FFT:    - NG and L (and dx = L/NG) affects highest possible k and k space resolution        - Mode 1 k1 = 2.*np.pi/L = dk        - Highest mode kn = 2.*np.pi/(2.*dx) = np.pi/dx = np.pi*NG/L        - Number of modes = NG        - Increase resolution in k space <=> decrease dk <=> increase L        - Similarily, for dt and T_end (and steps = int(T_end/dt))         - Mode 1 omega1 = 2.*np.pi/T_end = domega        - Highest mode omegan = 2.*np.pi/(2.*dt) = np.pi/dt = np.pi*steps/T_end        - Number of modes = steps        - Increase resolution in omega space <=> decrease domega <=> increase T_end- Don't modify .py and .cpp for input and simulation parameters- Data size of simulation results:    - Assuming 1D code (ES1) with E field in 128 grid, 40000 particles        - Particle parameters: m, q, r, v        - Field parameters: rho, phi, E        - Data size for each step = (40000*4+128x3)*8(bytes/parameter)=1283072 bytes ~ 1.28 MB/step (at least)        - Assuming fully 3D code with both E and B fields in 128x128x128 grid, 10000 particles        - Particle parameters: m, q, r_x, r_y, r_z, v_x, v_y, v_z        - Field parameters: rho, J_x, J_y, J_z, E_x, E_y, E_z, B_x, B_y, B_z        - Data size for each step = (10000*8+128**3*10)*8(bytes/parameter)=168412160 bytes ~ 168 MB/step (at least)